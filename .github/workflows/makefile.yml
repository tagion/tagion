name: Makefile CI
on:
  pull_request:
    branches: [ "develop" ]
  push: 
    branches: [ "develop" ]
concurrency: 
  group: ${{ github.head_ref }}
  cancel-in-progress: true
env:
  ## Sets environment variable
  TARGET_BUILD: x86_64-linux
  PARALEL: 4
  RETENTION_DAYS_BINS: 1
  TAGION_CACHE_DIR: ~/tagion_cache 
  RUN_SCENARIOUS_PARALEL: true
  BUILD_FLAGS: DFLAGS="\$(DVERSION)=OLD_TRANSACTION"
  ## TODO: add ldc2/dmd switch & version
jobs:
  build_and_unittest:
    runs-on: self-hosted
    steps:
      - name: Cleanup
        run: sudo rm -rf *
      - name: Checkout
        uses: actions/checkout@v3

      - name: Use cache of libs
        run: |
          if [ -d ${{ env.TAGION_CACHE_DIR }}/${{ env.TARGET_BUILD }} ]; then
            echo "Coping cache"
            mkdir -p ./build/${{ env.TARGET_BUILD }}
            ls ${{ env.TAGION_CACHE_DIR }}/${{ env.TARGET_BUILD}}/
            cp -fr ${{ env.TAGION_CACHE_DIR }}/${{ env.TARGET_BUILD}}/* ./build/${{ env.TARGET_BUILD }}/
            ls ./build/${{ env.TARGET_BUILD }}/
          else 
            echo "Cache not found"
          fi

      - name: Build
        run: |
          source ~/.bashrc
          export ${{ env.BUILD_FLAGS }}
          make bins -j ${{ env.PARALEL }}
          
      - name: Upload bins
        uses: actions/upload-artifact@v3
        with:
          name: core-bins
          path: build/${{ env.TARGET_BUILD }}/bin/tagion
          retention-days: ${{ env.RETENTION_DAYS_BINS }}

      - name: Make cache of libs
        run: |
          ls
          DIFF=$(diff --speed-large-files --recursive --brief ./build/${{ env.TARGET_BUILD}}/tmp ${{ env.TAGION_CACHE_DIR }}/${{ env.TARGET_BUILD }}/tmp)
          DIFF+=$(diff --speed-large-files --recursive --brief ./build/${{ env.TARGET_BUILD }}/lib ${{ env.TAGION_CACHE_DIR }}/${{ env.TARGET_BUILD }}/lib)
          if [ "$DIFF" != "" ] ; then
            sudo rm -rf ${{ env.TAGION_CACHE_DIR }}/${{ env.TARGET_BUILD }}
            sudo mkdir -p ${{ env.TAGION_CACHE_DIR }}/${{ env.TARGET_BUILD }}
            sudo /bin/cp -rf ./build/${{ env.TARGET_BUILD}}/tmp ${{ env.TAGION_CACHE_DIR }}/${{ env.TARGET_BUILD }}/
            sudo /bin/cp -rf ./build/${{ env.TARGET_BUILD }}/lib ${{ env.TAGION_CACHE_DIR }}/${{ env.TARGET_BUILD }}/
          fi

      - name: Run unittests
        run: |
          source ~/.bashrc
          export ${{ env.BUILD_FLAGS }}
          make unittest -j ${{ env.PARALEL }}
      - name: Upload unittest result
        uses: actions/upload-artifact@v3
        with:
          name: core-unittests-logs
          path: logs/${{ env.TARGET_BUILD }}/unittest.log

      - name: Check unittests
        run: cat logs/${{ env.TARGET_BUILD }}/unittest.log | grep -E "^[0-9]+ modules passed unittests"

      - name: Report unittests
        if: success()
        run: |
          RESULT=$(cat logs/${{ env.TARGET_BUILD }}/unittest.log | grep -E "^[0-9]+ modules passed unittests")
          echo -e "### :heavy_check_mark: Unittests passed \n $RESULT" >> $GITHUB_STEP_SUMMARY
      - name: Report unittests
        if: failure()
        run: |
          RESULT=$(cat logs/${{ env.TARGET_BUILD }}/unittest.log | grep FAILED)
          echo -e "### :heavy_exclamation_mark: Unittests passed \n $RESULT" >> $GITHUB_STEP_SUMMARY

  create_tagion_images:
    runs-on: self-hosted
    needs: build_and_unittest
    outputs:
      scenario_list: ${{ steps.scenario_list.outputs.scenarious }}
    steps:
      - name: Cleanup
        run: rm -rf * ; ls; pwd;

      - name: Download Docker context
        uses: actions/checkout@v3
        with:
          repository: tagion/tagion-docker
          token: ${{ secrets.GH_PAT }} # `GH_PAT` is a secret that contains your PAT

      - name: Download bins
        uses: actions/download-artifact@v3
        with:
          name: core-bins
          path: bins
 
      - name: Download QA tools
        uses: actions/checkout@v3
        with:
          repository: tagion/qa-framework
          token: ${{ secrets.GH_PAT }} # `GH_PAT` is a secret that contains your PAT
          path: qa-tools

      - name: Debug info
        run: ls; echo ===========; ls bins; echo ===========; ls qa-tools; pwd;

      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
      
      - name: Build tagion img
        run: docker build -t tagion/toolkit:$GITHUB_SHA . --target tagion
      - name: Build tagion-qa img
        run: docker build -t tagion/qa-toolkit:$GITHUB_SHA . --target tagion-qa

      - name: Push tagion img
        run: docker image push tagion/toolkit:$GITHUB_SHA
      - name: Push tagion-qa img
        run: docker image push tagion/qa-toolkit:$GITHUB_SHA

      - name: List scenarious
        id: scenario_list
        run: |
          SCENARIOUS=""
          while read f; do
              SCENARIOUS+="${f} "
          done < "./qa-tools/scenarious.txt"
          echo "scenarious=$SCENARIOUS" >> $GITHUB_OUTPUT

      - name: Report created docker
        if: success()
        run: |
          echo -e "### :heavy_check_mark: Docker created \n [tagion/toolkit:$GITHUB_SHA](https://hub.docker.com/repository/docker/tagion/toolkit) \n [tagion/qa-toolkit:$GITHUB_SHA](https://hub.docker.com/repository/docker/tagion/qa-toolkit)" >> $GITHUB_STEP_SUMMARY
    
      
  run_qa_scripts:
    runs-on: self-hosted
    needs: create_tagion_images
    steps: 
      - name: Cleanup
        run: rm -rf * ; ls; pwd;

      - name: Debug info - input
        run: echo ${{needs.create_tagion_images.outputs.scenario_list}} 
        
      - name: Pull docker img
        run: docker pull tagion/qa-toolkit:$GITHUB_SHA

      - name: Run scripts in paralel 
        if: env.RUN_SCENARIOUS_PARALEL == 'true'
        timeout-minutes: 10
        run: |
          set +e
          mkdir scenario-result
          for SCENARIO in ${{ needs.create_tagion_images.outputs.scenario_list }}; do
            echo "RUN SCENARIO: $SCENARIO"
            mkdir ./scenario-result/$SCENARIO
            docker run -d --rm --name $SCENARIO -v ${PWD}/scenario-result/$SCENARIO:/tgn/results/ tagion/qa-toolkit:$GITHUB_SHA run-qa.sh $SCENARIO
            echo "$SCENARIO executed"
          done
          sudo chmod -R 777 scenario-result
          DELAY=5
          all_containers_stoped=false
          while [ "$all_containers_stoped" = false ]
          do
              echo "START CHECKING"
              sleep $DELAY
              for CONTAINER in ${{ needs.create_tagion_images.outputs.scenario_list }}; do 
                echo "Check $CONTAINER"
                result=$( docker inspect -f '{{.State.Running}}' $CONTAINER 2>/dev/null )    
                echo "Check result: $result"
                if [ "$result" = true ]; then
                    echo 'Container $CONTAINER exists'
                    all_containers_stoped=false
                    break
                fi
                all_containers_stoped=true
              done
          done  
      - name: Run scripts in sequentially 
        if: env.RUN_SCENARIOUS_PARALEL != 'true'
        timeout-minutes: 10
        run: |
          mkdir scenario-result
          for SCENARIO in ${{ needs.create_tagion_images.outputs.scenario_list }}; do
            echo "RUN SCENARIO: $SCENARIO"
            mkdir ./scenario-result/$SCENARIO
            docker run --rm --name $SCENARIO -v ${PWD}/scenario-result/$SCENARIO:/tgn/results/ tagion/qa-toolkit:$GITHUB_SHA run-qa.sh $SCENARIO
            echo "$SCENARIO executed"
          done
          sudo chmod -R 777 scenario-result
      - name: log status
        run: |
          set +e
          PATH_TO_LOGS="./scenario-result/**/*.result.json"
          REPORT="|Scenario|Test case|Passed|Message|Error|\n|-|-|-|-|-|\n"
          failed_scenarios=false
            for logfile in $PATH_TO_LOGS
            do
              echo $logfile
              scenario_name=$( cat $logfile | jq '.scenario')
              result=$( cat $logfile | jq '.payload[]|(.name,.passed,.message?,.error?)')
              echo $scenario_name
              echo $result
              i=0
              while read line; do
                  echo "processning $line"
                  let "i+=1"
                  let "linenum=i%4"
                  echo "linenum=$linenum i=$i"
                  if [ "$linenum" -eq "1" ]; then
                      REPORT+="|$scenario_name|"
                  fi

                  if [ "$linenum" -eq "2" ]; then
                      if [ $line == "true" ]; then
                          REPORT+=":heavy_check_mark:|"
                      else
                          failed_scenarios=true
                          REPORT+=":heavy_exclamation_mark:|"
                      fi
                      continue;
                  fi

                  if [ "$linenum" -eq "0" ]; then
                      REPORT+="$line|\n"
                  else
                      REPORT+="$line|"
                  fi
                  
              echo $line; 
              done <<<"$result"
      
          done
          REPORT=$( echo "${REPORT//null/}" )
          REPORT=$( echo "${REPORT//\"/}" )
          echo -e "$REPORT"  >> $GITHUB_STEP_SUMMARY
          sudo chmod -R 777 scenario-result
          if $failed_scenarios 
          then
              echo "Scenarious failed"
          fi
      - name: upload artifacts
        if: always()
        uses: actions/upload-artifact@v2.2.0
        with:
          name: core-scenarious-results
          path: ./scenario-result/
          if-no-files-found: error
          retention-days: 5
      - name: Clean logs
        if: always()
        run: sudo rm -rf scenario-result
        
      - name: Clean docker container
        if: always()
        run: |
          ids=$(docker ps -a -q)
          for id in $ids
          do
           echo "$id"
           docker stop $id && docker rm $id
          done
